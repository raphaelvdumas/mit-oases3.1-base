/* 2/2000: revised to take care of problems with files generated by
   SUNOS. Compressed tags written as 4 byte integers. Characters
   written as short integers. 'MI' written as short also. <EKS
*/

/*    MATSUBS_.c are a set of Fortran callable C functions that
      can be used to generate Matlab Version 5 *.mat files. 
      Floating point data is stored as SINGLE PRECISION!!, so that,
      once in Matlab. it will be necessary to use the double()
      function on variables to do anything useful. Note that
      scalars (1 by 1 variables) are
      written in Matlab V5 "compressed form". Although the Matlab
      documentation states that Matlab should be able to read 
      single precision float scalares in non-compressed form, this
      did not seem to be the case, so the compressflag logic was
      reluctantly added to these functions.

      Routines included are:

matopen_: requests filename and opens a Mat file; writes 128 byte header

matsetup_(ndim,dim,padflag,namelen,name):
       sets up for a Matlab matrix of dimension "ndim", with corresponding
       sizes in the *dim array. Variable name is "name", with length of
       that name = "namelen". "padflag" is an OUTPUT of this function, 
       which is set of data needs to by padded to an even 16 byte boundary.

matwrite_(data,nvals,padflag):
       Writes one vector of length nvals to the Mat file. For a matrix, this
       function is called in a loop. If "padflag" is set, will pad the
       data to an evec 16 byte boundary.

matcsetup_(len,padflag,rem,namelen,name)
       Sets up for writing a 1 dimensional character array to matlab.
       Variable name is "name", with length of that name = "namelen".

       "rem": if total length: 2* (length of string) isn't multiple of 8,
       augment maintag.nbytes by rem, (but not datatag.nbytes)
       to signal that an extra rem bytes should pad the data after
       ALL the string is written. PADFLAG will also be set if rem not 0.

matcwrite_(data,nvals,padflag,rem)
       Writes the string of length nvals to the Mat file. Pads by rem
       if necessary to line things to 16 byte boundaries

See pp.f for examples of using these functions

Eddie Scheer, WHOI August,1999 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

char matname[128];

/* matopen: request file name and open the file; write 128 byte header*/
            
matopen_(fname,lname)
     char *fname;
     int *lname;
{
  char *header,*thestart;
  int hsize;
  short version[1],*sheader,theend[1];
  FILE *optr;
  
  /*  fprintf(stderr,"enter Matlab v5 matfile name: (should end in .mat)");
      scanf("%s",matname); */
  matname[0]='\0';
  strncat(matname,fname,*lname);
  if ((optr=fopen(matname,"w")) == NULL)
    {
      fprintf(stderr,"can't open %s\n",matname);
      exit(1);
    }
  fprintf(stderr,"Opened matlab file %s\n",matname);
  hsize = 124;
  header = (char *)calloc(hsize,sizeof(char));  
  thestart = "MATLAB 5.0";
  *version = 0x0100;    
  /* *theend is "MI" */
  *theend=0x4d49;
  sheader = (short *)header;
  strcpy(header,thestart);

  fwrite(header,sizeof(char),hsize,optr);
  fwrite(version,sizeof(short),1,optr);
  fwrite(theend,sizeof(short),1,optr);
  fclose(optr);
  return;
}

typedef struct {
     int type;   /* type */
     int nbytes; /* nbytes */
} TAGSTRUCT;


matsetup_(ndim,dim,padflag,namelen,name)
     int *ndim,*dim,*padflag,*namelen;
     char *name;
{
  int  miMatrix=14,miUINT32=6,miINT32=5,miINT8=1;
  int flag,iii,sz,compressflag,idum;

  char *varname;
  FILE *optr;

  TAGSTRUCT maintag;
  TAGSTRUCT flagtag;
  TAGSTRUCT dimtag;
  TAGSTRUCT nametag;
  TAGSTRUCT datatag;

  /* OPEN FOR APPENDING */
  if ((optr=fopen(matname,"a")) == NULL)
    {
      fprintf(stderr,"can't open %s\n",matname);
      exit(1);
    }

  /*SET UP FLAGTAG */
  flagtag.type = miUINT32;
  flagtag.nbytes = 8;
  flag = 0x00000007;
  /* last byte: 'class': 7 for single prec; 6 for double*/
  /* next to last byte: 'flags': 8 for complex; 0 for real*/

  /*SET UP DIMTAG */
  dimtag.type = miINT32;
  dimtag.nbytes = 4*(*ndim);
  
  /*SET UP NAMETAG */
  /* Varnames up to 8 characters long!! */
  varname = (char *)calloc(8,sizeof(char));  
  strncat(varname,name,*namelen);
  nametag.type = miINT8;
  nametag.nbytes = 8;

  /*SET UP DATATAG */
  datatag.type = 7;
  datatag.nbytes = sizeof(float);
  for(iii=0;iii<*ndim;iii++)
    datatag.nbytes *= dim[iii];

  /* compress if only one scalar single prec float (4 bytes) */
  compressflag = 0;
  if (datatag.nbytes <= 4)
    compressflag = 1;

  /* setup and write MAINTAG */
  maintag.type = miMatrix;
  fwrite(&(maintag.type),sizeof(int),1,optr);

  /* maintag.nbytes =
     normally 4*8 (for flag,dim,name,data tags)+the 4 nbytes fields
     For compressed data
       normally 4*8 (for flag,dim,name,data tags)+3 nbytes fields
       (data held in the data tag field*/
  if (compressflag == 0)
    maintag.nbytes = 
      4*8+flagtag.nbytes+dimtag.nbytes+nametag.nbytes+datatag.nbytes;
  else
    maintag.nbytes = 4*8+flagtag.nbytes+dimtag.nbytes+nametag.nbytes;

  /*if matrix size is odd, augment maintag.nbytes by 4, (but not
    datatag.nbytes) to signal that an extra 4 bytes should pad the data...
    only after ALL the data for the variable is written */

  *padflag = 0;

  /* Should never have to pad if one scalar sing prec float*/
  if (compressflag == 0)
    if ((datatag.nbytes/sizeof(float))%2 != 0)
      {
	maintag.nbytes += 4;
	*padflag = 1;
      }

  fwrite(&(maintag.nbytes),sizeof(int),1,optr);
  fwrite(&(flagtag.type),sizeof(int),1,optr);
  fwrite(&(flagtag.nbytes),sizeof(int),1,optr);
  fwrite(&flag,sizeof(int),1,optr);
  /* next is just a dummy */
  fwrite(&flag,sizeof(int),1,optr);
  fwrite(&(dimtag.type),sizeof(int),1,optr);
  fwrite(&(dimtag.nbytes),sizeof(int),1,optr);
  for (iii=0;iii<*ndim;iii++)
    fwrite(dim+iii,sizeof(int),1,optr);
  fwrite(&(nametag.type),sizeof(int),1,optr);
  fwrite(&(nametag.nbytes),sizeof(int),1,optr);
  fwrite(varname,sizeof(char),nametag.nbytes,optr);
  if (compressflag == 0){
    fwrite(&(datatag.type),sizeof(int),1,optr);
    fwrite(&(datatag.nbytes),sizeof(int),1,optr);}
  else{
    idum = ((datatag.nbytes<<16)& 0xffff0000) | (datatag.type & 0x0000ffff);
    fwrite(&idum,sizeof(int),1,optr);}
  fclose(optr);
}

matwrite_(data,nvals,padflag)
     float *data;
     int *nvals,*padflag;
{
  /* force varname to 16 */
  float dum = 0;
  char *varname;
  FILE *optr;

  /* OPEN FOR APPENDING */
  if ((optr=fopen(matname,"a")) == NULL)
    {
      fprintf(stderr,"can't open %s\n",matname);
      exit(1);
    }
  fwrite(data,sizeof(float),*nvals,optr);
  if (*padflag==1)
    {
      fwrite(&dum,sizeof(float),1,optr);
    }
  fclose(optr);
}

matcsetup_(len,padflag,rem,namelen,name)
     int *len,*padflag,*rem,*namelen;
     char *name;
{
  int  miMatrix=14,miUINT32=6,miINT32=5,miINT8=1;
  int flag,iii,compressflag,dum,idum;

  char *varname;
  FILE *optr;

  TAGSTRUCT maintag;
  TAGSTRUCT flagtag;
  TAGSTRUCT dimtag;
  TAGSTRUCT nametag;
  TAGSTRUCT datatag;

  /* OPEN FOR APPENDING */
  if ((optr=fopen(matname,"a")) == NULL)
    {
      fprintf(stderr,"can't open %s\n",matname);
      exit(1);
    }

  /*SET UP FLAGTAG */
  flagtag.type = miUINT32;
  flagtag.nbytes = 8;
  flag = 0x00000004;
  /* last two nibbles: 'class': 7 for single prec; 6 for double; 4 FOR CHAR*/
  /* next to last two nibbles: 'flags': 8 for complex; 0 for real*/

  /*SET UP DIMTAG */
  dimtag.type = miINT32;
  dimtag.nbytes = 8;

  /*SET UP NAMETAG */
  varname = (char *)calloc(8,sizeof(char));  
  strncat(varname,name,*namelen);
  nametag.type = miINT8;
  nametag.nbytes = 8;

  /*SET UP DATATAG */
  /* 4 for 16 bit unsigned: chars writen out with nulls */
  datatag.type = 4;
  datatag.nbytes = (*len)*2*sizeof(char);
  
  compressflag = 0;
  if (datatag.nbytes <= 4)
    compressflag = 1;

  /*  fprintf(stderr,"C compressflag %d\n",compressflag);*/
  /* setup and write MAINTAG */
  maintag.type = miMatrix;
  fwrite(&(maintag.type),sizeof(int),1,optr);

  /* maintag.nbytes = 4*8 (for flag,dim,name,data tags)+the 4 nbytes fields*/

  if (compressflag == 0)
    maintag.nbytes = 
      4*8+flagtag.nbytes+dimtag.nbytes+nametag.nbytes+datatag.nbytes;
  else
    maintag.nbytes = 4*8+flagtag.nbytes+dimtag.nbytes+nametag.nbytes;

  /*Character array seems to be char, \0 char \0: each char is 2 bytes.
    if total length: 2* (length of string) isn't multiple of 8,
    augment maintag.nbytes by rem, (but not datatag.nbytes)
    to signal that an extra rem bytes should pad the data after
    ALL the string is written */

  *padflag = 0;

  if (compressflag == 0)
    *rem = ((*len)%4);
  else
    *rem = ((*len)%2);
  
  if (*rem != 0)
    {
      if (compressflag == 0){
	*rem = 4-*rem;
	maintag.nbytes += *rem*2*sizeof(char);}
      else{
	*rem = 2-*rem;
	/*	maintag.nbytes += *rem*sizeof(char);*/}
      *padflag = 1;
    }

  fwrite(&(maintag.nbytes),sizeof(int),1,optr);
  fwrite(&(flagtag.type),sizeof(int),1,optr);
  fwrite(&(flagtag.nbytes),sizeof(int),1,optr);
  fwrite(&flag,sizeof(int),1,optr);
  /* next is just a dummy */
  fwrite(&flag,sizeof(int),1,optr);
  fwrite(&(dimtag.type),sizeof(int),1,optr);
  fwrite(&(dimtag.nbytes),sizeof(int),1,optr);
  dum = 1;
  fwrite(&dum,sizeof(int),1,optr);
  fwrite(len,sizeof(int),1,optr);
  fwrite(&(nametag.type),sizeof(int),1,optr);
  fwrite(&(nametag.nbytes),sizeof(int),1,optr);
  fwrite(varname,sizeof(char),nametag.nbytes,optr);
  if (compressflag == 0){
    fwrite(&(datatag.type),sizeof(int),1,optr);
    fwrite(&(datatag.nbytes),sizeof(int),1,optr);}
  else{
    idum = ((datatag.nbytes<<16)& 0xffff0000) | (datatag.type & 0x0000ffff);
    fwrite(&idum,sizeof(int),1,optr);}
  fclose(optr);
}

matcwrite_(data,nvals,padflag,rem)
     char *data;
     int *nvals,*padflag,*rem;
{

  int iii;
  short idum;
  char dum[2];
  char *varname,*carray;
  FILE *optr;

  carray = (char *)calloc(124,sizeof(char));  

  dum[0] = '\0';

  strncat(carray,data,*nvals);

  /* OPEN FOR APPENDING */
  if ((optr=fopen(matname,"a")) == NULL)
    {
      fprintf(stderr,"can't open %s\n",matname);
      exit(1);
    }

  for (iii=0;iii< *nvals;iii++){
    idum = ((carray[iii])& 0x00ff);
    fwrite(&idum,sizeof(short),1,optr);}
/*
    fwrite(&carray[iii],sizeof(char),1,optr);
    fwrite(&dum,sizeof(char),1,optr);}
*/
  if (*padflag==1)
    for (iii=1;iii<= *rem;iii++){
      /*      fprintf(stderr,"padding......\n");*/
      fwrite(dum,sizeof(char),1,optr);
      fwrite(dum,sizeof(char),1,optr);}
  fclose(optr);
}





